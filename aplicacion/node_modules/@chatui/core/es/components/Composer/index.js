import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";

/* eslint-disable react/forbid-prop-types */
import React, { useState, useRef, useEffect, useImperativeHandle } from 'react';
import clsx from 'clsx';
import { Input } from '../Input';
import { Recorder } from '../Recorder';
import { Toolbar } from '../Toolbar';
import { ClickOutside } from '../ClickOutside';
import { Popover } from '../Popover';
import { SendConfirm } from '../SendConfirm';
import { ToolbarItem } from './ToolbarItem';
import { Action } from './Action';
import riseInput from './riseInput';
import parseDataTransfer from '../../utils/parseDataTransfer';
import toggleClass from '../../utils/toggleClass';
var NO_HOME_BAR = 'S--noHomeBar';
export var Composer = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$text = props.text,
      initialText = _props$text === void 0 ? '' : _props$text,
      _props$inputType = props.inputType,
      initialInputType = _props$inputType === void 0 ? 'text' : _props$inputType,
      wideBreakpoint = props.wideBreakpoint,
      _props$placeholder = props.placeholder,
      placeholder = _props$placeholder === void 0 ? '请输入...' : _props$placeholder,
      _props$recorder = props.recorder,
      recorder = _props$recorder === void 0 ? {} : _props$recorder,
      onInputTypeChange = props.onInputTypeChange,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onSend = props.onSend,
      onImageSend = props.onImageSend,
      onAccessoryToggle = props.onAccessoryToggle,
      _props$toolbar = props.toolbar,
      toolbar = _props$toolbar === void 0 ? [] : _props$toolbar,
      onToolbarClick = props.onToolbarClick,
      rightAction = props.rightAction;

  var _useState = useState(initialText),
      _useState2 = _slicedToArray(_useState, 2),
      text = _useState2[0],
      _setText = _useState2[1];

  var _useState3 = useState(initialInputType || 'text'),
      _useState4 = _slicedToArray(_useState3, 2),
      inputType = _useState4[0],
      setInputType = _useState4[1];

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isAccessoryOpen = _useState6[0],
      setAccessoryOpen = _useState6[1];

  var _useState7 = useState(''),
      _useState8 = _slicedToArray(_useState7, 2),
      accessoryContent = _useState8[0],
      setAccessoryContent = _useState8[1];

  var _useState9 = useState(null),
      _useState10 = _slicedToArray(_useState9, 2),
      pastedImage = _useState10[0],
      setPastedImage = _useState10[1];

  var composerRef = useRef(null);
  var inputRef = useRef(null);
  var focused = useRef(false);
  var blurTimer = useRef();
  var popoverTarget = useRef();
  var isMountRef = useRef(false);

  var _useState11 = useState(false),
      _useState12 = _slicedToArray(_useState11, 2),
      isWide = _useState12[0],
      setWide = _useState12[1];

  useEffect(function () {
    var mq = wideBreakpoint && window.matchMedia ? window.matchMedia("(min-width: ".concat(wideBreakpoint, ")")) : false;

    function handleMq(e) {
      setWide(e.matches);
    }

    setWide(mq && mq.matches);

    if (mq) {
      mq.addListener(handleMq);
    }

    return function () {
      if (mq) {
        mq.removeListener(handleMq);
      }
    };
  }, [wideBreakpoint]);
  useEffect(function () {
    toggleClass('S--wide', isWide);

    if (!isWide) {
      setAccessoryContent('');
    }
  }, [isWide]);
  useEffect(function () {
    if (isMountRef.current && onAccessoryToggle) {
      onAccessoryToggle(isAccessoryOpen);
    }
  }, [isAccessoryOpen]);
  useEffect(function () {
    isMountRef.current = true;
    riseInput(inputRef.current, composerRef.current);
  }, []);
  useImperativeHandle(ref, function () {
    return {
      setText: function setText(val) {
        _setText(val);
      }
    };
  });

  function handleInputTypeChange() {
    var isVoice = inputType === 'voice';
    var nextType = isVoice ? 'text' : 'voice';
    setInputType(nextType);

    if (isVoice) {
      var input = inputRef.current;
      input.focus(); // eslint-disable-next-line no-multi-assign

      input.selectionStart = input.selectionEnd = input.value.length;
    }

    if (onInputTypeChange) {
      onInputTypeChange(nextType);
    }
  }

  function handleInputFocus(e) {
    clearTimeout(blurTimer.current);
    toggleClass(NO_HOME_BAR, true);
    focused.current = true;

    if (onFocus) {
      onFocus(e);
    }
  }

  function handleInputBlur(e) {
    blurTimer.current = setTimeout(function () {
      toggleClass(NO_HOME_BAR, false);
      focused.current = false;
    }, 0);

    if (onBlur) {
      onBlur(e);
    }
  }

  function send() {
    onSend('text', text);

    _setText('');

    if (focused.current) {
      inputRef.current.focus();
    }
  }

  function handleInputKeyDown(e) {
    if (!e.shiftKey && e.keyCode === 13) {
      send();
      e.preventDefault();
    }
  }

  function handleTextChange(value, e) {
    _setText(value);

    if (onChange) {
      onChange(value, e);
    }
  }

  function handlePaste(e) {
    parseDataTransfer(e, function (file) {
      setPastedImage(file);
    });
  }

  function handleImageCancel() {
    setPastedImage(null);
  }

  function handleImageSend() {
    if (onImageSend && pastedImage) {
      onImageSend(pastedImage).then(function () {
        setPastedImage(null);
      });
    }
  }

  function handleSendBtnClick(e) {
    send();
    e.preventDefault();
  }

  function handleAccessoryToggle() {
    setAccessoryOpen(!isAccessoryOpen);
  }

  function handleAccessoryBlur() {
    setTimeout(function () {
      setAccessoryOpen(false);
      setAccessoryContent('');
    });
  }

  function handleToolbarClick(item, e) {
    if (onToolbarClick) {
      onToolbarClick(item, e);
    }

    if (item.render) {
      popoverTarget.current = e.currentTarget;
      setAccessoryContent(item.render);
    }
  }

  function handlePopoverClose() {
    setAccessoryContent('');
  }

  function renderExtra() {
    var accessory = accessoryContent || /*#__PURE__*/React.createElement(Toolbar, {
      items: toolbar,
      onClick: handleToolbarClick
    });
    return /*#__PURE__*/React.createElement(ClickOutside, {
      onClick: handleAccessoryBlur
    }, accessory);
  }

  var isInputText = inputType === 'text';
  var inputTypeIcon = isInputText ? 'mic' : 'keyboard';
  var hasToolbar = toolbar.length > 0;

  var renderInput = function renderInput() {
    return /*#__PURE__*/React.createElement("div", {
      className: clsx({
        'S--invisible': !isInputText
      })
    }, /*#__PURE__*/React.createElement(Input, {
      className: "Composer-input",
      value: text,
      rows: 1,
      autoSize: true,
      ref: inputRef,
      placeholder: placeholder,
      enterKeyHint: "send",
      onFocus: handleInputFocus,
      onBlur: handleInputBlur,
      onKeyDown: handleInputKeyDown,
      onChange: handleTextChange,
      onPaste: onImageSend ? handlePaste : undefined
    }), pastedImage && /*#__PURE__*/React.createElement(SendConfirm, {
      file: pastedImage,
      onCancel: handleImageCancel,
      onSend: handleImageSend
    }));
  };

  if (isWide) {
    return /*#__PURE__*/React.createElement("div", {
      className: "Composer Composer--lg",
      ref: composerRef
    }, hasToolbar && /*#__PURE__*/React.createElement("div", {
      className: "Composer-toolbar"
    }, toolbar.map(function (item) {
      return /*#__PURE__*/React.createElement(ToolbarItem, {
        item: item,
        onClick: function onClick(e) {
          return handleToolbarClick(item, e);
        },
        key: item.type
      });
    })), accessoryContent && /*#__PURE__*/React.createElement(Popover, {
      active: !!accessoryContent,
      target: popoverTarget.current,
      onClose: handlePopoverClose
    }, accessoryContent), /*#__PURE__*/React.createElement("div", {
      className: "Composer-inputWrap"
    }, renderInput()), /*#__PURE__*/React.createElement(Action, {
      className: "Composer-sendBtn",
      icon: "paper-plane",
      color: "primary",
      disabled: !text,
      onMouseDown: handleSendBtnClick,
      "aria-label": "\u53D1\u9001"
    }));
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "Composer",
    ref: composerRef
  }, recorder.canRecord && /*#__PURE__*/React.createElement(Action, {
    className: "Composer-inputTypeBtn",
    "data-icon": inputTypeIcon,
    icon: inputTypeIcon,
    onClick: handleInputTypeChange,
    "aria-label": isInputText ? '切换到语音输入' : '切换到键盘输入'
  }), /*#__PURE__*/React.createElement("div", {
    className: "Composer-inputWrap"
  }, renderInput(), !isInputText && /*#__PURE__*/React.createElement(Recorder, recorder)), !text && rightAction && /*#__PURE__*/React.createElement(Action, rightAction), hasToolbar && /*#__PURE__*/React.createElement(Action, {
    className: clsx('Composer-toggleBtn', {
      active: isAccessoryOpen
    }),
    icon: "plus",
    onClick: handleAccessoryToggle,
    "aria-label": isAccessoryOpen ? '关闭工具栏' : '展开工具栏'
  }), text && /*#__PURE__*/React.createElement(Action, {
    className: "Composer-sendBtn",
    icon: "paper-plane",
    color: "primary",
    onMouseDown: handleSendBtnClick,
    "aria-label": "\u53D1\u9001"
  })), isAccessoryOpen && renderExtra());
});